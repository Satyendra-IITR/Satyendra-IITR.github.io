---
layout:     post
comments:   true
title:      LLVM
date:       2019-03-10 11:21:29
summary:    First experiences with LLVM
categories: plt
---

LLVM or Low Level Virtual Machine is a powerful compiler technology used to develop compiler frontends and backends. Ever since I got to know about LLVM, I wanted to try it out and finally made a simple `C to LLVM` compiler by looking for resources online. In this blog I would be expressing some of the cool features that I got to know about this awesome software.

### How LLVM works ?

The basic idea behind this whole project is creating a middleware for all the frontend 'High level' programming languages before finally generating the assembly codes. Thie middleware is called **Intermediate Representation (IR)** that can be optimized and tinkered upon without having to rewrite the entire code generation logic. Not only producing the optimized IR can be done independently, producing the assembly code out of the **same IR** for different architectures can be done separately. This saves a lot of time and reduces unnecessary redundany of code.

An example LLVM IR for Hello World code in C : 

```bash
; ModuleID = 'hello.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [12 x i8] c"Hello World\00", align 1

; Function Attrs: nounwind uwtable
define i32 @main() #0 {
  %1 = alloca i32, align 4
  store i32 0, i32* %1, align 4
  %2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str, i32 0, i32 0))
  ret i32 0
}

declare i32 @printf(i8*, ...) #1

attributes #0 = { nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.8.0-2ubuntu4 (tags/RELEASE_380/final)"}

```

Currently most of tech leads use LLVM as thier compiler backend. This also adds on to why one should learn about LLVM. 

### Reversing LLVM IR to C/CPP

The commonly known tool is called **Clang** that is a C compiler created by Apple as a part of LLVM project. It is quite cool and has a lot of functionality that can be easily googled up. One of the most amazing things that I found was reversing the LLVM IR to possible C code. Now this is one important thing that can be taken advantage and be used to a different language's code that produces the same LLVM IR.

Here is reversed CPP code for the above LLVM IR.

```cpp
// Generated by llvm2cpp - DO NOT MODIFY!

#include <llvm/Pass.h>
#include <llvm/ADT/SmallVector.h>
#include <llvm/Analysis/Verifier.h>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/CallingConv.h>
#include <llvm/IR/Constants.h>
#include <llvm/IR/DerivedTypes.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/GlobalVariable.h>
#include <llvm/IR/IRPrintingPasses.h>
#include <llvm/IR/InlineAsm.h>
#include <llvm/IR/Instructions.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/LegacyPassManager.h>
#include <llvm/IR/Module.h>
#include <llvm/Support/FormattedStream.h>
#include <llvm/Support/MathExtras.h>
#include <algorithm>
using namespace llvm;

Module* makeLLVMModule();

int main(int argc, char**argv) {
  Module* Mod = makeLLVMModule();
  verifyModule(*Mod, PrintMessageAction);
  PassManager PM;
  PM.add(createPrintModulePass(&outs()));
  PM.run(*Mod);
  return 0;
}


Module* makeLLVMModule() {
 // Module Construction
 Module* mod = new Module("hello.ll", getGlobalContext());
 mod->setDataLayout("");
 mod->setTargetTriple("x86_64-pc-linux-gnu");
 
 // Type Definitions
 ArrayType* ArrayTy_0 = ArrayType::get(IntegerType::get(mod->getContext(), 8), 12);
 
 PointerType* PointerTy_1 = PointerType::get(ArrayTy_0, 0);
 
 std::vector<Type*>FuncTy_2_args;
 FunctionType* FuncTy_2 = FunctionType::get(
  /*Result=*/IntegerType::get(mod->getContext(), 32),
  /*Params=*/FuncTy_2_args,
  /*isVarArg=*/false);
 
 PointerType* PointerTy_3 = PointerType::get(IntegerType::get(mod->getContext(), 32), 0);
 
 PointerType* PointerTy_4 = PointerType::get(IntegerType::get(mod->getContext(), 8), 0);
 
 std::vector<Type*>FuncTy_6_args;
 FuncTy_6_args.push_back(PointerTy_4);
 FunctionType* FuncTy_6 = FunctionType::get(
  /*Result=*/IntegerType::get(mod->getContext(), 32),
  /*Params=*/FuncTy_6_args,
  /*isVarArg=*/true);
 
 PointerType* PointerTy_5 = PointerType::get(FuncTy_6, 0);
 
 
 // Function Declarations
 
 Function* func_main = mod->getFunction("main");
 if (!func_main) {
 func_main = Function::Create(
  /*Type=*/FuncTy_2,
  /*Linkage=*/GlobalValue::ExternalLinkage,
  /*Name=*/"main", mod); 
 func_main->setCallingConv(CallingConv::C);
 }
 AttributeSet func_main_PAL;
 {
  SmallVector<AttributeSet, 4> Attrs;
  AttributeSet PAS;
   {
    AttrBuilder B;
    B.addAttribute(Attribute::NoUnwind);
    B.addAttribute(Attribute::UWTable);
    PAS = AttributeSet::get(mod->getContext(), ~0U, B);
   }
  
  Attrs.push_back(PAS);
  func_main_PAL = AttributeSet::get(mod->getContext(), Attrs);
  
 }
 func_main->setAttributes(func_main_PAL);
 
 Function* func_printf = mod->getFunction("printf");
 if (!func_printf) {
 func_printf = Function::Create(
  /*Type=*/FuncTy_6,
  /*Linkage=*/GlobalValue::ExternalLinkage,
  /*Name=*/"printf", mod); // (external, no body)
 func_printf->setCallingConv(CallingConv::C);
 }
 AttributeSet func_printf_PAL;
 {
  SmallVector<AttributeSet, 4> Attrs;
  AttributeSet PAS;
   {
    AttrBuilder B;
    PAS = AttributeSet::get(mod->getContext(), ~0U, B);
   }
  
  Attrs.push_back(PAS);
  func_printf_PAL = AttributeSet::get(mod->getContext(), Attrs);
  
 }
 func_printf->setAttributes(func_printf_PAL);
 
 // Global Variable Declarations

 
 GlobalVariable* gvar_array__str = new GlobalVariable(/*Module=*/*mod, 
 /*Type=*/ArrayTy_0,
 /*isConstant=*/true,
 /*Linkage=*/GlobalValue::PrivateLinkage,
 /*Initializer=*/0, // has initializer, specified below
 /*Name=*/".str");
 gvar_array__str->setAlignment(1);
 
 // Constant Definitions
 Constant *const_array_7 = ConstantDataArray::getString(mod->getContext(), "Hello World", true);
 ConstantInt* const_int32_8 = ConstantInt::get(mod->getContext(), APInt(32, StringRef("1"), 10));
 ConstantInt* const_int32_9 = ConstantInt::get(mod->getContext(), APInt(32, StringRef("0"), 10));
 std::vector<Constant*> const_ptr_10_indices;
 const_ptr_10_indices.push_back(const_int32_9);
 const_ptr_10_indices.push_back(const_int32_9);
 Constant* const_ptr_10 = ConstantExpr::getGetElementPtr(gvar_array__str, const_ptr_10_indices);
 
 // Global Variable Definitions
 gvar_array__str->setInitializer(const_array_7);
 
 // Function Definitions
 
 // Function: main (func_main)
 {
  
  BasicBlock* label_11 = BasicBlock::Create(mod->getContext(), "",func_main,0);
  
  // Block  (label_11)
  AllocaInst* ptr_12 = new AllocaInst(IntegerType::get(mod->getContext(), 32), "", label_11);
  ptr_12->setAlignment(4);
  StoreInst* void_13 = new StoreInst(const_int32_9, ptr_12, false, label_11);
  void_13->setAlignment(4);
  CallInst* int32_14 = CallInst::Create(func_printf, const_ptr_10, "", label_11);
  int32_14->setCallingConv(CallingConv::C);
  int32_14->setTailCall(false);
  AttributeSet int32_14_PAL;
  int32_14->setAttributes(int32_14_PAL);
  
  ReturnInst::Create(mod->getContext(), const_int32_9, label_11);
  
 }
 
 return mod;
}
```

### Producing different Architecture codes

One more awesome functionality recently added is that you can produce LLVM IR for a differnet hardware architecture without having to even run code on that architecture system.

# Creating an actual Compiler

These are just important thing I found while working on making a compiler. There are a lot of tutorials available on how to do so, here are just common things that are used in accomplishing the same.

### Blocks

Using LLVM to write a backend for the compiler uses the idea of blocks. The different blocks can be equipped with feature sets individually as per wish. These blocks are then linked with each other while generating the IR. The `makeLLVMmodule()` uses methods to stackup these blocks according to language grammar provided and generates a LLVM module that is run to execute the program.

### Inbuilt functions
Each of Blocks are accompanied by **Function Pointers** that tells the LLVM that these are functions that need to be analyzed. Luckily one need not to write all the function logic for some basic things like **Binary Operation**, these come handy as inbuilt functions in LLVM. for some trivial **C/CPP functions** can also be accessed using **twine()**.  

### SSA
In Compiler Theory, SSA stands for **Static Single Assignment** and LLVM sticks to it while generating very basic optimized code. SSA can be added easily to one's codegen logic.

### Optimization
There are different prebuilt optimizations available that can be top level accessed using **Pass Manager**. One can customize a new one if required and run using the pass manager.

